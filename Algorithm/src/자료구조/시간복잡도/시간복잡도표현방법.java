/*

알고리즘 복잡도 표현 방법

1. 알고리즘 복잡도 계산이 필요한 이유
	- 하나의 문제를 푸는 알고리즘은 다양하다

2. 알고리즘 복잡도 계산 항목
	- 시간 복잡도 : 알고리즘의 실행 속도
	- 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

3. 입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행 시간을 지배한다.

4. 알고리즘 성능 표기법
	- Big O (빅-오) 표기법 : O(N)
		- 알고리즘 최악의 실행 시간을 표기
		- 가장 많이/일반적으로 사용
		- 아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미
	- Ω (오메가) 표기법 : Ω(N)
		- 알고리즘 최상의 실행 시간 표기
	- Θ (세타) 표기법 : Θ(N)
	 	- 알고리즘 평균 실행 시간 표기

5. Big O (빅-오) 표기법
	- O (입력)
		- 입력 n에 따라 결정되는 시간 복잡도 함수
		- O(1), O(logn), O(n), O(nlogn), O(n²), O(2^n), o(n!) 등으로 표기
		- 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
			- O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(2^n) < o(n!)
				- logN의 베이스는 2-log2n
	- 단순하게 입력 n에 따라, 몇번 실행되는지 계산
		- 표현식에 가장 큰 영향을 미치는 n의 단위로 표기
		
			- 무조건 2회(상수회) 실행 : O(1)
				if(n>10){ println(n); }
			
			- n에 따라 n번, n+10번, 3n+10번등 실행 : O(n)
				- 이중 반복문이지만, 상위는 상수로 반목하므로, 3n 실행
				for(int num=0; num<3; num ++){
					for(int i=0; i<n; i++){
						println(i);
					}
				}

			- n에따라 n², n² + 1000번, 100n² -100, 300n² +1번 등 실행 : O(n²)
				- 상중 반복문이지만, 상위는 상수로 반복하므로 3n² 실행
				for(int i=0; i<3; i++){
					for(int num=0; num<n; num++){
						for(int i = 0; i<n; i++){
							println(i);
						}
					}
				}

6. 빅 오 입력값 표기 법
	- 만약 시간 복잡도 함수가 2n² + 3n이면
		- 가장 높은 차수 2n²
		- 상수는 실제 큰 영향 없음
		- 즉, O(n²)


7. 간단한 예쩨
	- 1~10 더하기
		ex) for(int i=0; i<=n; i++)  => O(n)
		ex) n(n+1) / 2 -> O(1)
		두번째가 성능이 더 좋다


*/